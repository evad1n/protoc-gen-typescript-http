package plugin

import (
	"github.com/evad1n/protoc-gen-typescript-http/internal/codegen"
	"github.com/evad1n/protoc-gen-typescript-http/internal/protowalk"
	"google.golang.org/protobuf/reflect/protoreflect"
)

type messageEntry struct {
	message        protoreflect.MessageDescriptor
	usedInRequest  bool
	usedInResponse bool
}

type serviceEntry struct {
	service protoreflect.ServiceDescriptor
}

var (
	messageRegistry       = make(map[protoreflect.FullName]messageEntry)
	serviceRegistry       = make(map[protoreflect.ServiceDescriptor]serviceEntry)
	enumRegistry          = make(map[protoreflect.EnumDescriptor]protoreflect.EnumDescriptor)
	wellKnownTypeRegistry = make(map[WellKnown]WellKnown)
)

type packageGenerator struct {
	pkg   protoreflect.FullName
	files []protoreflect.FileDescriptor
}

func (p packageGenerator) Generate(f *codegen.File) error {
	p.Register()
	if err := p.generateFromRegistry(f); err != nil {
		return err
	}

	return nil
}

func (p packageGenerator) Register() {
	protowalk.WalkFiles(p.files, func(desc protoreflect.Descriptor) bool {
		if wkt, ok := WellKnownType(desc); ok {
			wellKnownTypeRegistry[wkt] = wkt
			return false
		}
		switch v := desc.(type) {
		case protoreflect.MessageDescriptor:
			if v.IsMapEntry() {
				return false
			}
			messageRegistry[v.FullName()] = messageEntry{message: v}
		case protoreflect.EnumDescriptor:
			enumRegistry[v] = v
		case protoreflect.ServiceDescriptor:
			serviceRegistry[v] = serviceEntry{service: v}
		}
		return true
	})

	if options.verbose {
		log("Registered package:", p.pkg)
		log("Messages registered:", len(messageRegistry))
		log("Services registered:", len(serviceRegistry))
		log("Enums registered:", len(enumRegistry))
		log("Well known types registered:", len(wellKnownTypeRegistry))
	}

	// Second pass on the services to determine what messages are used for the request/response
	for serviceDescriptor := range serviceRegistry {
		methods := serviceDescriptor.Methods()
		for i := 0; i < methods.Len(); i++ {
			method := methods.Get(i)

			inputMessageName := method.Input().FullName()
			inputMessageEntry, ok := messageRegistry[inputMessageName]
			if !ok {
				log("Warning: input message", inputMessageName, "not found in registry for service", serviceDescriptor.FullName())
			} else {
				messageRegistry[inputMessageName] = messageEntry{
					message:        inputMessageEntry.message,
					usedInRequest:  true,
					usedInResponse: inputMessageEntry.usedInResponse,
				}
			}

			outputMessageName := method.Output().FullName()
			outputMessageEntry, ok := messageRegistry[outputMessageName]
			if !ok {
				log("Warning: output message", outputMessageName, "not found in registry for service", serviceDescriptor.FullName())
			} else {
				messageRegistry[outputMessageName] = messageEntry{
					message:        outputMessageEntry.message,
					usedInRequest:  outputMessageEntry.usedInRequest,
					usedInResponse: true,
				}
			}
		}
	}

	// Log all messages that are used in requests or responses
	if options.verbose {
		log("Messages used in requests:")
		for name, entry := range messageRegistry {
			if entry.usedInRequest {
				log(" -", name)
			}
		}
		log("Messages used in responses:")
		for name, entry := range messageRegistry {
			if entry.usedInResponse {
				log(" -", name)
			}
		}
	}
}

func (p packageGenerator) generateFromRegistry(f *codegen.File) error {
	GeneratePackageHeader(f)

	var walkErr error

	for _, t := range wellKnownTypeRegistry {
		f.Write(t.TypeDeclaration())
	}

	for _, e := range enumRegistry {
		enumGenerator{pkg: p.pkg, enum: e}.Generate(f)
	}

	if len(serviceRegistry) > 0 {
		GenerateServiceHeader(f)
	}

	for _, m := range messageRegistry {
		messageGenerator{
			pkg:            p.pkg,
			message:        m.message,
			usedInRequest:  m.usedInRequest,
			usedInResponse: m.usedInResponse,
		}.Generate(f)
	}

	for _, s := range serviceRegistry {
		if err := (serviceGenerator{pkg: p.pkg, service: s.service}).Generate(f); err != nil {
			walkErr = err
			continue
		}
	}

	return walkErr
}

func GeneratePackageHeader(f *codegen.File) {
	f.Write("// Code generated by protoc-gen-typescript-http. DO NOT EDIT.")
	f.Write("/* eslint-disable camelcase */")
	f.Write("// @ts-nocheck")
	f.Write()
}
